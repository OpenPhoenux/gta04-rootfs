#
# clone the currently running system to NAND
# works only if booted from SD
#

# do sanity tests
# * that the rootfs is not coming from nand
# * that boot.scr does not overwrite U-Boot

# DEFAULT="-x -b -k -j" ### we can't write X-Loader yet
DEFAULT="-k -u"

[ "$1" == "" ] && set - $DEFAULT

if [ ! -x /usr/sbin/nandwrite ]
then
	echo "mtd-utils not installed (apt-get install mtd-utils)"
	exit 1
fi

# check if requested components are available

for cmd
do
	case "$cmd" in
		-x )
			echo "flashing X-Loader from Linux not available (HW-ECC kernel support needed)"
			exit 1
			if [ ! -r /boot/x-load.flash ]
			then
				echo x-loader missing
				exit 1
			fi
			# MLO is not stored in NAND but should be in rootfs
			# so that we can create bootable SD cards
			if [ ! -r /boot/MLO ]
			then
				echo MLO missing
				exit 1
			fi
			;;
		-b )
			echo "flashing U-Boot from Linux not available (HW-ECC kernel support needed)"
			exit 1
			if [ ! -r /boot/u-boot.bin ]
			then
				echo U-Boot missing
				exit 1
			fi
			if [ ! -r /boot/boot.scr ]
			then
				echo boot script missing
				exit 1
			fi
			if [ ! -r /boot/menu.rgb16z -a -r /boot/splash.rgb16z ]
			then
				echo boot menu images missing
				exit 1
			fi
			;;
		-k )
			if [ ! -r /boot/uImage ]
			then
				echo kernel image missing
				exit 1
			fi
			;;
		-j )
			echo jffs2 is no longer supported
			exit 1
			;;
		-j | -u )
			FOUND=false

			# clean up current rootfs before copying
			apt-get clean
			depmod -a
			rm -rf /usr/lib/locale/*
			locale-gen

			if fgrep -q 'root=/dev/mtdblock4' /proc/cmdline
			then
				echo "can't overwrite active rootfs"
				exit 1
			fi
			while read FILESYSTEM BLOCKS USED AVAILABLE USEPERCENT MOUNTED
			do
				case $FILESYSTEM in
					rootfs | /dev/root )
						FOUND=true
						# fixme: we don't copy /var/cache so this estimate is wrong
						if [ $USED -gt 1000000 ]
						then
							echo "root file system is definitively too big (${USED}k) for 512 MB NAND flash"
						##	exit 1
						fi
				esac
			done < <(df /)

			if ! $FOUND
			then
				echo rootfs not found
				exit 1
			fi

			;;
		* ) echo unknown option "$cmd"
			echo "-x x-loader"
			echo "-b u-boot and boot scripts"
			echo "-k kernel"
			echo "-j rootfs in jffs2 format"
			echo "-u rootfs in UBIFS format (experimental)"
			echo "default: $DEFAULT"
			exit 1
			;;
	esac
done

# install requested components

for cmd
do
	case "$cmd" in
		-x ) echo flashing X-loader

			# FIXME: this must be written with HW_ECC enabled!

			flash_eraseall /dev/mtd0 &&
			# write 4 copies at different locations? use -s option
			nandwrite -p /dev/mtd0 -s 0x00000 /boot/x-load.flash &&
			nandwrite -p /dev/mtd0 -s 0x20000 /boot/x-load.flash &&
			nandwrite -p /dev/mtd0 -s 0x40000 /boot/x-load.flash &&
			nandwrite -p /dev/mtd0 -s 0x60000 /boot/x-load.flash || exit 1
			;;

		-b ) echo flashing U-Boot and boot scripts

			flash_eraseall /dev/mtd1 &&
			nandwrite -p /dev/mtd1 -s 0x000000 /boot/u-boot.bin || exit 1

			echo copying boot scripts to end of U-Boot partition

			nandwrite -p /dev/mtd1 -s 0x150000 /boot/splash.rgb16z &&
			nandwrite -p /dev/mtd1 -s 0x190000 /boot/menu.rgb16z &&
			nandwrite -p /dev/mtd1 -s 0x1d0000 /boot/boot.scr || exit 1

			nanddump /dev/mtd2 | xxd | head
			;;

		-k ) echo flashing Kernel

			UIMAGE="/boot/uImage"	# the uImage on the SD card
			DTB="$(fw_printenv -n devicetree)"	# hardware dependent device tree (if it exists)
			if [ "$DTB" ] && (which mkimage >/dev/null)
			then # merge uImage and device tree BLOB for NAND partition
				echo unpacking "$UIMAGE"
				VERSION=$(mkimage -l "$UIMAGE" | fgrep "Image Name:" | sed 's/Image Name: *//')
				LOADADDRESS=0x$(mkimage -l "$UIMAGE" | fgrep "Load Address:" | sed 's/Load Address: *//')
				ENTRYPOINT=0x$(mkimage -l "$UIMAGE" | fgrep "Entry Point:" | sed 's/Entry Point: *//')
				ZIMAGE="/tmp/$$-zImage"
				dd if="$UIMAGE" ibs=64 skip=1 | dd of="$ZIMAGE" ibs=8 skip=1 || exit 1
				echo appending "/boot/${DTB}.dtb"
				cat "/boot/${DTB}.dtb" >>"$ZIMAGE" || exit 1
				UIMAGE="/tmp/$$-uImage" # new UIMAGE file
				echo repacking into "$UIMAGE"
				mkimage -A arm -O linux -T kernel -C none -a "$LOADADDRESS" -e "$ENTRYPOINT" -n "$VERSION" -d "$ZIMAGE" "$UIMAGE" || exit 1
			fi
			flash_eraseall /dev/mtd3 &&
			nandwrite -p /dev/mtd3 "$UIMAGE" || exit 1
			### someone must ensure that the modules are matching the kernel
			;;

		-j ) echo flashing Rootfs as jffs2

			if fgrep -q 'root=/dev/mtdblock4' /proc/cmdline
			then
				echo "can't overwrite active rootfs"
				exit 1
			fi
			umount /dev/mtdblock4
			flash_eraseall -j /dev/mtd4 &&
			mkdir -p /mnt/nand &&
			mount -t jffs2 /dev/mtdblock4 /mnt/nand &&
			(
			cd /mnt/nand &&
				(
				echo "copying files (takes a while)"
				rm -rf *	# clear previous rootfs (if any) -- this leaves .* files!
				# copy to jffs2
				tar --exclude .bash_history --exclude ./mnt --exclude ./media --exclude ./var/cache --exclude ./tmp --exclude ./proc --exclude ./sys --exclude lost+found -cf - -C / . | tar xpf - --checkpoint=100
				echo "copied"
				echo "patching and syncing"
				mkdir -p ./mnt ./media ./tmp ./proc ./sys
				mkdir -p ./var/cache/apt/archives ./var/cache/apt/archives/partial ./var/cache/debconf
				cp /var/cache/debconf/config.dat ./var/cache/debconf/config.dat
				rm -f ./home/.bash_history ./root/.bash_history ./.bash_history
				# apply any important patches (which?)
				# echo "creating new sshd key"
				# e.g. clear sshd key
				# so we should save the keys before doing that and restore them
				# rm -f ./etc/ssh/ssh_host_*
				# dpkg-reconfigure openssh-server
				sync
				echo "synced"
				)
			) || echo erasing/flashing jffs2 to NAND failed
			df
			umount /mnt/nand
			rm -rf /mnt/nand
			;;

		-u ) echo flashing Rootfs as UBIFS
			
			if fgrep -q 'root=/dev/mtdblock4' /proc/cmdline
			then
				echo "can't overwrite active rootfs"
				exit 1
			fi
			umount /mnt/nand
			umount ubi0:gta04-rootfs	# if mounted
			ubidetach /dev/ubi_ctrl -m 4	# if attached
			ubiformat -y /dev/mtd4
			ubiattach /dev/ubi_ctrl -m 4
			ubimkvol /dev/ubi0 -N gta04-rootfs -m &&
			mkdir -p /mnt/nand &&
			mount -t ubifs ubi0:gta04-rootfs /mnt/nand &&
			(
			cd /mnt/nand &&
				(
				UIMAGE="/boot/uImage"	# the uImage on the SD card
				MODULES=/lib/modules/$(mkimage -l "$UIMAGE" | fgrep "Image Name:" | sed 's/Image Name: *//' | sed 's/Linux-//')

				echo "copying files (takes a while)"
				rm -rf *	# clear previous rootfs (if any) -- this leaves .* files!
				tar --exclude .bash_history --exclude ./mnt --exclude './debian-*' --exclude ./media --exclude ./var/cache --exclude ./var/log  --exclude ./var/spool --exclude ./tmp --exclude ./proc --exclude ./sys --exclude lost+found --exclude ./boot --exclude ./lib/modules -cf - -C / . | tar xpf - --checkpoint=100
				echo "copied; now adding kernel modules"
				tar -cf - -C / ./lib/modules/$MODULES | tar xpf - --checkpoint=100
				echo "patching and syncing"
				mkdir -p ./mnt/nand ./media ./tmp ./proc ./sys ./boot
				mkdir -p ./var/cache/apt/archives ./var/cache/apt/archives/partial ./var/cache/debconf
				cp /var/cache/debconf/config.dat ./var/cache/debconf/config.dat
				sed s/^rootfs/#rootfs/ /etc/fstab >./etc/fstab	# comment out the rootfs entry because rootfs mounting fails
				rm -f ./home/.bash_history ./root/.bash_history ./.bash_history
				echo "MLO/X-Loader, U-Boot and Kernel are stored in separate NAND partitions and not here" >./boot/booting_from_nand
				# apply any important patches (which?)
				# echo "creating new sshd key"
				# e.g. clear sshd key
				# so we should save the keys before doing that and restore them
				# rm -f ./etc/ssh/ssh_host_*
				# dpkg-reconfigure openssh-server
				sync
				echo "synced"
				)
			) || echo erasing/flashing ubifs to NAND failed
			df
#			umount /mnt/nand
#			rm -rf /mnt/nand
			;;

	esac
done

echo "done."